import type {
  BuildResult,
  GradientStop,
  ParsedBorderToken,
  ParsedColorToken,
  ParsedCubicBezierToken,
  ParsedDimensionToken,
  ParsedDurationToken,
  ParsedFontFamilyToken,
  ParsedFontWeightToken,
  ParsedNumberToken,
  ParsedGradientToken,
  ParsedLinkToken,
  ParsedShadowToken,
  ParsedStrokeStyleToken,
  ParsedToken,
  ParsedTransitionToken,
  ParsedTypographyToken,
  Plugin,
  ResolvedConfig,
} from '@cobalt-ui/core';

import pluginCSS, {varRef, type Options as PluginCSSOptions} from '@cobalt-ui/plugin-css';
import {indent} from '@cobalt-ui/utils';
import {encode, formatFontFamilyNames} from './util.js';

const CAMELCASE_RE = /([^A-Z])([A-Z])/g;
const VAR_TOKENS = '__token-values';
const VAR_TYPOGRAPHY = '__token-typography-mixins';
const VAR_ERROR = '__cobalt-error';
const TRAILING_WS_RE = /\s+$/gm;
const DEPENDENCIES = ['sass:list', 'sass:map'];

export interface Options {
  /** output file (default: "./tokens/index.sass") */
  filename?: string;
  /** */
  pluginCSS?: PluginCSSOptions;
  /** use indented syntax (.sass)? (default: false) */
  indentedSyntax?: boolean;
  /** embed files in CSS? */
  embedFiles?: boolean;
  /** handle different token types */
  transform?: (token: ParsedToken, mode?: string) => string;
}

export default function pluginSass(options?: Options): Plugin {
  let config: ResolvedConfig;
  let ext = options?.indentedSyntax ? '.sass' : '.scss';
  let filename = `${options?.filename?.replace(/(\.(sass|scss))?$/, '') || 'index'}${ext}`;

  const cssPlugin = options?.pluginCSS ? pluginCSS(options.pluginCSS) : undefined;

  const semi = options?.indentedSyntax ? '' : ';';
  const cbOpen = options?.indentedSyntax ? '' : ' {';
  const cbClose = options?.indentedSyntax ? '' : '} ';

  const TOKEN_FN = `@function token($tokenName, $modeName: default)${cbOpen}
  @if map.has-key($${VAR_TOKENS}, $tokenName) == false${cbOpen}
    @error "No token named \\"#{$tokenName}\\""${semi}
  ${cbClose}
  $_token: map.get($${VAR_TOKENS}, $tokenName)${semi}
  @if map.has-key($_token, "__cobalt-error")${cbOpen}
    @error map.get($_token, "__cobalt-error")${semi}
  ${cbClose}
  @if map.has-key($_token, $modeName) {
    @return map.get($_token, $modeName)${semi}
  ${cbClose}@else${cbOpen}
    @return map.get($_token, default)${semi}
  ${cbClose}
${cbClose}`
    .trim()
    .replace(TRAILING_WS_RE, '');

  const LIST_MODES_FN = `@function listModes($tokenName)${cbOpen}
  @if map.has-key($${VAR_TOKENS}, $tokenName) == false${cbOpen}
    @error "No token named \\"#{$tokenName}\\""${semi}
  ${cbClose}
  $_modes: ();
  @each $k in map.get($${VAR_TOKENS}, $tokenName)${cbOpen}
    @if $k != "default"${cbOpen}
      $_modes: list.append($_modes, $k);
    ${cbClose}
  ${cbClose}
  @return $_modes;
${cbClose}`
    .trim()
    .replace(TRAILING_WS_RE, '');

  const TYPOGRAPHY_MIXIN = `@mixin typography($tokenName, $modeName: default)${cbOpen}
  @if map.has-key($${VAR_TYPOGRAPHY}, $tokenName) == false${cbOpen}
    @error "No typography mixin named \\"#{$tokenName}\\""${semi}
  ${cbClose}
  $_mixin: map.get($${VAR_TYPOGRAPHY}, $tokenName)${semi}
  $_properties: map.get($_mixin, default)${semi}
  @if map.has-key($_mixin, $modeName)${cbOpen}
    $_properties: map.get($_mixin, $modeName)${semi}
  ${cbClose}
  @each $_property, $_value in $_properties${cbOpen}
    #{$_property}: #{$_value}${semi}
  ${cbClose}
${cbClose}`
    .trim()
    .replace(TRAILING_WS_RE, '');

  return {
    name: '@cobalt-ui/plugin-sass',
    config(c): void {
      config = c;
      if (cssPlugin && typeof cssPlugin.config === 'function') cssPlugin.config(c);
    },
    async build({tokens, metadata, rawSchema}): Promise<BuildResult[]> {
      let output: string[] = [];
      const typographyTokens: ParsedTypographyToken[] = [];
      const customTransform = typeof options?.transform === 'function' ? options.transform : undefined;
      const prefix = options?.pluginCSS?.prefix || '';

      // metadata (SassDoc)
      output.push('////');
      output.push(`/// ${metadata.name || 'Design Tokens'}`);
      output.push('/// Autogenerated from tokens.json.');
      output.push('/// DO NOT EDIT!');
      output.push('////');
      output.push('');

      // basic tokens
      output.push(...DEPENDENCIES.map((name) => `@use "${name}"${semi}`));
      output.push('');
      output.push(indent(`$${VAR_TOKENS}: (`, 0));
      for (const token of tokens) {
        // special case: typography tokens needs @mixins, so bypass normal route
        if (token.$type === 'typography') {
          typographyTokens.push(token);
          output.push(indent(`"${token.id}": (`, 1));
          output.push(indent(`"${VAR_ERROR}": "This is a typography mixin. Use \`@include typography(\\"${token.id}\\")\` instead.",`, 2));
          output.push(indent(`),`, 1));
          continue;
        }

        output.push(indent(`"${token.id}": (`, 1));

        // default value
        let value = cssPlugin ? varRef(token.id, {prefix}) : (customTransform && customTransform(token)) || defaultTransformer(token);
        if (token.$type === 'link' && options?.embedFiles) value = encode(value as string, config.outDir);
        output.push(indent(`default: (${value}),`, 2));

        // modes
        for (const modeName of Object.keys((token.$extensions && token.$extensions.mode) || {})) {
          let modeValue = cssPlugin ? varRef(token.id, {prefix}) : (customTransform && customTransform(token, modeName)) || defaultTransformer(token, modeName);
          if (token.$type === 'link' && options?.embedFiles) modeValue = encode(modeValue as string, config.outDir);
          output.push(indent(`"${modeName}": (${modeValue}),`, 2));
        }
        output.push(indent('),', 1));
      }
      output.push(`)${semi}`);
      output.push('');

      // typography tokens
      output.push(`$${VAR_TYPOGRAPHY}: (`);
      for (const token of typographyTokens) {
        output.push(indent(`"${token.id}": (`, 1));
        output.push(indent(`default: (`, 2));
        const defaultProperties = Object.entries(token.$value); // legacy: support camelCase properties
        defaultProperties.sort(([a], [b]) => a.localeCompare(b));
        for (const [k, value] of defaultProperties) {
          const property = k.replace(CAMELCASE_RE, '$1-$2').toLowerCase();
          if (cssPlugin) {
            output.push(indent(`"${property}": (${varRef(token.id, {prefix, suffix: property})}),`, 3));
          } else {
            output.push(indent(`"${property}": (${Array.isArray(value) ? formatFontFamilyNames(value) : value}),`, 3));
          }
        }
        output.push(indent(`),`, 2));
        for (const [mode, modeValue] of Object.entries((token.$extensions && token.$extensions.mode) || {})) {
          output.push(indent(`"${mode}": (`, 2));
          const modeProperties = Object.entries(modeValue);
          modeProperties.sort(([a], [b]) => a.localeCompare(b));
          for (const [k, value] of modeProperties) {
            const property = k.replace(CAMELCASE_RE, '$1-$2').toLowerCase();
            output.push(indent(`"${property}": (${Array.isArray(value) ? formatFontFamilyNames(value) : value}),`, 3));
          }
          output.push(indent(`),`, 2));
        }
        output.push(indent(`),`, 1));
      }
      output.push(`)${semi}`);
      output.push('');

      // utilities
      output.push(TOKEN_FN);
      output.push('');
      output.push(LIST_MODES_FN);
      output.push('');
      output.push(TYPOGRAPHY_MIXIN);
      output.push('');

      return [
        {
          filename,
          contents: output.join('\n'),
        },
        // build pluginCSS (if used)
        ...((cssPlugin && (await cssPlugin.build({tokens, metadata, rawSchema}))) || []),
      ];
    },
  };
}

/** transform color */
export function transformColor(value: ParsedColorToken['$value']): string {
  return String(value);
}
/** transform dimension */
export function transformDimension(value: ParsedDimensionToken['$value']): string {
  return String(value);
}
/** transform duration */
export function transformDuration(value: ParsedDurationToken['$value']): string {
  return String(value);
}
/** transform fontFamily */
export function transformFontFamily(value: ParsedFontFamilyToken['$value']): string {
  return formatFontFamilyNames(value);
}
/** transform fontWeight */
export function transformFontWeight(value: ParsedFontWeightToken['$value']): number {
  return Number(value);
}
/** transform cubic beziÃ©r */
export function transformCubicBezier(value: ParsedCubicBezierToken['$value']): string {
  return `cubic-bezier(${value.join(', ')})`;
}
/** transform number */
export function transformNumber(value: ParsedNumberToken['$value']): number {
  return Number(value);
}
/** transform link */
export function transformLink(value: ParsedLinkToken['$value']): string {
  return `url('${value}')`;
}
/** transform strokeStyle */
export function transformStrokeStyle(value: ParsedStrokeStyleToken['$value']): string {
  return String(value);
}
/** transform border */
export function transformBorder(value: ParsedBorderToken['$value']): string {
  return [transformDimension(value.width), transformStrokeStyle(value.style), transformColor(value.color)].join(' ');
}
/** transform shadow */
export function transformShadow(value: ParsedShadowToken['$value']): string {
  return [transformDimension(value.offsetX), transformDimension(value.offsetY), transformDimension(value.blur), transformDimension(value.spread), transformDimension(value.color)].join(' ');
}
/** transform gradient */
export function transformGradient(value: ParsedGradientToken['$value']): string {
  return value.map((g: GradientStop) => `${transformColor(g.color)} ${g.position * 100}%`).join(', ');
}
/** transform transition */
export function transformTransition(value: ParsedTransitionToken['$value']): string {
  const timingFunction = value.timingFunction ? `cubic-bezier(${value.timingFunction.join(',')})` : undefined;
  return [value.duration, value.delay, timingFunction].filter((v) => v !== undefined).join(' ');
}

export function defaultTransformer(token: ParsedToken, mode?: string): string | number {
  if (mode && (!token.$extensions?.mode || !token.$extensions.mode[mode])) throw new Error(`Token ${token.id} missing "$extensions.mode.${mode}"`);
  switch (token.$type) {
    case 'color': {
      return transformColor(mode ? ((token.$extensions as any).mode[mode] as typeof token.$value) : token.$value);
    }
    case 'dimension': {
      return transformDimension(mode ? ((token.$extensions as any).mode[mode] as typeof token.$value) : token.$value);
    }
    case 'duration': {
      return transformDuration(mode ? ((token.$extensions as any).mode[mode] as typeof token.$value) : token.$value);
    }
    case 'font' as 'fontFamily':
    case 'fontFamily': {
      return transformFontFamily(mode ? ((token.$extensions as any).mode[mode] as typeof token.$value) : token.$value);
    }
    case 'fontWeight': {
      return transformFontWeight(mode ? ((token.$extensions as any).mode[mode] as typeof token.$value) : token.$value);
    }
    case 'cubicBezier': {
      return transformCubicBezier(mode ? ((token.$extensions as any).mode[mode] as typeof token.$value) : token.$value);
    }
    case 'number': {
      return transformNumber(mode ? ((token.$extensions as any).mode[mode] as typeof token.$value) : token.$value);
    }
    case 'link': {
      return transformLink(mode ? ((token.$extensions as any).mode[mode] as typeof token.$value) : token.$value);
    }
    case 'strokeStyle': {
      return transformStrokeStyle(mode ? ((token.$extensions as any).mode[mode] as typeof token.$value) : token.$value);
    }
    case 'border': {
      return transformBorder(mode ? {...token.$value, ...((token.$extensions as any).mode[mode] as typeof token.$value)} : token.$value);
    }
    case 'shadow': {
      return transformShadow(mode ? {...token.$value, ...((token.$extensions as any).mode[mode] as typeof token.$value)} : token.$value);
    }
    case 'gradient': {
      return transformGradient(mode ? {...token.$value, ...((token.$extensions as any).mode[mode] as typeof token.$value)} : token.$value);
    }
    case 'transition': {
      return transformTransition(mode ? {...token.$value, ...((token.$extensions as any).mode[mode] as typeof token.$value)} : token.$value);
    }
    default: {
      throw new Error(`No transformer defined for $type: ${token.$type} tokens`);
    }
  }
}
